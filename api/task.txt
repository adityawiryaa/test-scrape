Distributed Configuration Management
Overview
Implement a distributed configuration management using Golang with the following components:
Controller: Central configuration management service
Agent: Configuration receiver and worker manager
Worker: HTTP service that executes configured tasks

Architecture Components
1. Controller Service
The Controller acts as the central hub for configuration management and agent registration.
Responsibilities
Configuration Management:
Accept configuration updates from administrators via API
Persist configurations in a database (simple SQLite is also acceptable)
Make configurations available for agents to poll
Track configuration versions to detect changes
Single configuration applies to all registered agents
Agent Registration:
Provide a protected registration endpoint (static credentials acceptable)
Authenticate incoming agent registration requests
Generate unique agent IDs for registered agents
Post-Registration Actions:
When a new agent registers, the Controller must:
Generate Unique Agent ID: Create a unique identifier for the agent (use UUID)
Store Agent Information: Persist agent registration details in the database
Create Initial Configuration: Store default or latest configuration for the agent
Return Connection Details, respond with:
Agent ID (unique identifier)
Poll endpoint URL
Polling interval (in second unit)
API Endpoints
POST /register
Authentication: Required (static credentials for the agent to register)
Request: Agent identification information
Response example:
json
 {
    "agent_id": "uuid-here",
    "poll_url": "/config",
    "poll_interval_seconds": 30
  }

POST /config
Authentication: Required (for administrator)
Request: New configuration data
Response: Success confirmation
Action: Updates global configuration version, applied to all agents

GET /config
Authentication: Required (agent credentials, can use credential used by agent to register itself)
Response: Current worker configuration (same for all agents)
Headers: Include ETag or version for change detection
Behavior: Returns the latest global configuration



2. Agent Service
The Agent acts as a bridge between the Controller and the Worker, managing configuration synchronization.
Responsibilities
Startup Sequence:
Read local configuration file / environment variables containing:
Controller URL
Authentication credentials to the controller
Register with the Controller via /register endpoint
Receive agent ID and polling details from Controller response
Start polling loop
Configuration Synchronization:
Periodically poll the Controller's /config endpoint
Compare received configuration with cached version
Detect configuration changes using version/ETag comparison
Make sure that the polling interval always up to date with the configuration from the Controller (the polling interval can be changed dynamically on runtime based on controller response)
Architecture Components:
The Agent contains two main subsystems:
Controller-Poller:
Maintains periodic connection to the Controller
Polls for configuration updates at regular intervals
Detects configuration changes
Caches current configuration and its version
Worker-Manager:
Forwards received configurations to the Worker via /config endpoint
Only sends updates when configuration has changed
Manages Worker lifecycle (optional. Worker lifecycle can be managed outside of agent)
Configuration Flow
Controller ← Agent (Controller-Poller polls) → Agent forwards to Worker (/config endpoint)


3. Worker Service
The Worker is an HTTP service that executes tasks based on dynamically received configurations.
Responsibilities
Configuration Management:
Start with empty/default configuration
Accept configuration updates via /config endpoint from the Agent
Store and apply the latest configuration
Log configuration changes to console
Configuration Structure:
{
  "url": "https://example.com/api/endpoint"
}

Task Execution:
Expose /hit endpoint for external requests
On request to /hit:
Read the current configuration
Execute HTTP GET request to the configured URL
Return the response body to the caller
API Endpoints
POST /config
- Caller: Agent
- Request: Worker configuration (JSON)
- Response: Success confirmation
- Action: Logs new configuration to console

GET /hit
- Caller: External user
- Response: Result from configured URL
- Behavior: Executes GET request to configured URL and proxies response


Complete Flow Example
Step-by-Step Execution
Controller Initialization
Controller service starts
Connects to database
Starts HTTP API server
Agent Registration
Agent service starts
Reads controller URL and credentials from config file / environment variables
Sends registration request to Controller
Controller Response
Controller generates unique agent ID
Stores agent registration in database
Returns agent ID and polling configuration to agent
Agent Polling Loop
Agent starts periodic polling based on controller’s response (e.g., every 30 seconds)
Sends GET request to /config
Receives current global configuration with version/ETag
Compares with cached version
Configuration Change Detection
If configuration has changed:
Agent updates its cached version
Agent forwards new configuration to Worker
Worker Configuration
Agent starts Worker (if not already running) (optional, worker lifecycle can be managed externally)
Sends configuration to Worker via POST /config
Worker logs the new configuration
Task Execution
User executes: curl http://<worker-url>/hit
Worker reads current configuration
Worker sends: GET <configured-url>
Worker returns response to user
Example
Configuration:
{
  "url": "https://ip.me"
}

User Request:
curl http://worker.local:8080/hit

Worker Behavior:
Reads current configuration: url = "https://ip.me"
Executes: GET https://ip.me
Receives response: 1.2.3.4 (user's public IP)
Returns to user: 1.2.3.4

Architecture Diagram

Bonus Requirements
Be Creative and enhance the system architecture
If you have better idea about how the controller can distribute the configuration to a huge number of agents, please implement it as long as the main goal is still the same.
Implement Exponential Backoff when retrieving config from the controller
If the agent cannot retrieve configuration from the controller, implement retry with Exponential Backoff (can be different with poll interval). Agent and worker must continue operating with the existing configuration if the controller is not available.
Containerization
Dockerize all services:
Controller:
Standalone Docker Compose configuration
Includes Controller service and database (if using separate DB)
Proper volume mounting for persistence
Agent + Worker:
Combined Docker Compose configuration
Both services in the same compose file
Proper networking between Agent and Worker
Environment variables for Controller URL
API doc in swagger generated automatically from the code
Generate Swagger/OpenAPI documentation automatically from the code
Include all endpoints with request/response examples

All stack deployed in real server
Deploy all services in the real server accessible from public, and write the details in the docs.


Technical Requirements
Language and Tools
Programming Language: Golang
Database: any familiar database (sqlite is fine)

Deliverables
Source Code
Complete implementation of Controller, Agent, and Worker
Clear project structure
Proper error handling
Configuration management (files or environment variables)
Documentation
README.md with compile and setup instructions
API documentation (swaggerfile, if implemented)
Configuration examples
Architecture explanation (if you implement it differently)
Docker Configuration (if implemented)
Docker Compose files for each component
Dockerfiles for each service
Environment variable documentation

